import { describe, it, expect, vi } from "vitest";
import { render, screen, fireEvent } from "@testing-library/react";
import { ConfigForm } from "./ConfigForm";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

/**
 * Component tests for ConfigForm
 * User Story 2 T141: Form validation tests
 */

// Mock the hooks
vi.mock("../hooks/useConfig", () => ({
  useConfig: vi.fn(),
  useUpdateConfig: vi.fn(),
}));

const { useConfig, useUpdateConfig } = await import("../hooks/useConfig");

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  });
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

describe("ConfigForm", () => {
  const mockConfig = {
    maxTradeUsdt: 100,
    maxPositionUsdt: 1000,
    autoTrade: false,
    highValueThresholdUsdt: 500,
    createdAt: "2025-11-14T00:00:00.000Z",
    updatedAt: "2025-11-14T10:00:00.000Z",
  };

  it("should display loading state", () => {
    vi.mocked(useConfig).mockReturnValue({
      data: undefined,
      isLoading: true,
      error: null,
    } as any);

    render(<ConfigForm />, { wrapper: createWrapper() });

    expect(screen.getByText(/Loading configuration/i)).toBeInTheDocument();
  });

  it("should display error state", () => {
    vi.mocked(useConfig).mockReturnValue({
      data: undefined,
      isLoading: false,
      error: new Error("Failed to fetch config"),
    } as any);

    render(<ConfigForm />, { wrapper: createWrapper() });

    expect(screen.getByText(/Failed to load config/i)).toBeInTheDocument();
  });

  it("should render form with config values", () => {
    vi.mocked(useConfig).mockReturnValue({
      data: mockConfig,
      isLoading: false,
      error: null,
    } as any);

    vi.mocked(useUpdateConfig).mockReturnValue({
      mutate: vi.fn(),
      isPending: false,
    } as any);

    render(<ConfigForm />, { wrapper: createWrapper() });

    expect(screen.getByLabelText(/Max Trade/i)).toHaveValue(100);
    expect(screen.getByLabelText(/Max Position/i)).toHaveValue(1000);
    expect(screen.getByLabelText(/High-Value Threshold/i)).toHaveValue(500);
  });

  it("should validate positive amounts", () => {
    const mockMutate = vi.fn();
    
    vi.mocked(useConfig).mockReturnValue({
      data: mockConfig,
      isLoading: false,
      error: null,
    } as any);

    vi.mocked(useUpdateConfig).mockReturnValue({
      mutate: mockMutate,
      isPending: false,
    } as any);

    const alertSpy = vi.spyOn(window, "alert").mockImplementation(() => {});

    render(<ConfigForm />, { wrapper: createWrapper() });

    // Set invalid value
    const maxTradeInput = screen.getByLabelText(/Max Trade/i);
    fireEvent.change(maxTradeInput, { target: { value: "-50" } });

    // Try to submit
    const saveButton = screen.getByText(/Save Configuration/i);
    fireEvent.click(saveButton);

    // Should show validation error
    expect(alertSpy).toHaveBeenCalledWith(
      expect.stringContaining("positive number")
    );
    expect(mockMutate).not.toHaveBeenCalled();

    alertSpy.mockRestore();
  });

  it("should validate position >= trade constraint", () => {
    const mockMutate = vi.fn();
    
    vi.mocked(useConfig).mockReturnValue({
      data: mockConfig,
      isLoading: false,
      error: null,
    } as any);

    vi.mocked(useUpdateConfig).mockReturnValue({
      mutate: mockMutate,
      isPending: false,
    } as any);

    const alertSpy = vi.spyOn(window, "alert").mockImplementation(() => {});

    render(<ConfigForm />, { wrapper: createWrapper() });

    // Set position < trade
    const maxTradeInput = screen.getByLabelText(/Max Trade/i);
    const maxPositionInput = screen.getByLabelText(/Max Position/i);
    
    fireEvent.change(maxTradeInput, { target: { value: "1000" } });
    fireEvent.change(maxPositionInput, { target: { value: "500" } });

    // Try to submit
    const saveButton = screen.getByText(/Save Configuration/i);
    fireEvent.click(saveButton);

    // Should show validation error
    expect(alertSpy).toHaveBeenCalledWith(
      expect.stringContaining("greater than or equal to max trade")
    );
    expect(mockMutate).not.toHaveBeenCalled();

    alertSpy.mockRestore();
  });

  it("should submit valid configuration", () => {
    const mockMutate = vi.fn();
    
    vi.mocked(useConfig).mockReturnValue({
      data: mockConfig,
      isLoading: false,
      error: null,
    } as any);

    vi.mocked(useUpdateConfig).mockReturnValue({
      mutate: mockMutate,
      isPending: false,
    } as any);

    render(<ConfigForm />, { wrapper: createWrapper() });

    // Change values
    const maxTradeInput = screen.getByLabelText(/Max Trade/i);
    fireEvent.change(maxTradeInput, { target: { value: "200" } });

    // Submit
    const saveButton = screen.getByText(/Save Configuration/i);
    fireEvent.click(saveButton);

    // Should call mutate with new values
    expect(mockMutate).toHaveBeenCalledWith(
      expect.objectContaining({
        maxTradeUsdt: 200,
        maxPositionUsdt: 1000,
        autoTrade: false,
        highValueThresholdUsdt: 500,
      })
    );
  });

  it("should display timestamps", () => {
    vi.mocked(useConfig).mockReturnValue({
      data: mockConfig,
      isLoading: false,
      error: null,
    } as any);

    vi.mocked(useUpdateConfig).mockReturnValue({
      mutate: vi.fn(),
      isPending: false,
    } as any);

    render(<ConfigForm />, { wrapper: createWrapper() });

    expect(screen.getByText(/Last updated:/i)).toBeInTheDocument();
    expect(screen.getByText(/Created:/i)).toBeInTheDocument();
  });
});
